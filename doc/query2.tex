
The goal of query 2 is to identify outliers that consume significantly high amount of energy. The plug is counted as outlier if the median load of the plug is more than the median load of all the plugs in the system for a given sliding window (1 hr or 24 hrs). We are able to achieve a throughput of more than 800 thousand events per second using a single threaded C++ program.

\subsubsection{The Median Algorithm for query 2}
In query 2, we need to calculate median of large amounts of data frequently. This leads to a clear trade off between computational complexity and accuracy of the median. Note that this is different from computing median for continuously streaming data because we need to compute median for a fixed size large window. We define a container which provides basic functionality of inserting a new element, deleting a given element and finally providing the approximate median for currently existing data in the container. We first insert all the elements into the container corresponding to the window and then delete the oldest element while sliding the window. Deleting the oldest element is not required in case of streaming median calculations. We, now, propose an algorithm to compute median which takes constant time for every operation in the given scenario with very low relative error.

The basic idea is to construct a histogram of the data using fixed number of bins (M-1). The histogram is then queried to find median of the data. We sort the first M distinct values inserted into the container and use them in order to build up the (M-1) bins. Every $i^{th}$ value corresponds to the starting of $i^{th}$ bin and every bin is associated with a frequency. Frequency denotes the frequency of the data greater and equal to $i^{th}$ lowest value (including) to less than $(i+1)^{th}$ lowest value (excluding). We also store the index of the bin containing the median after a insertion or deletion is performed, cumulative sum of the frequencies upto and including the bin in which median resides and the total number of values inserted into the container.



Now the three operations are implemented as follows:

In case of query 2, we need to compute the median everytime we receive an event. So every insert and/or deletion will be followed by a call to the \textit{getMedian} function of the container. We, therefore, used this nature of the problems, and optimized the asymptotic complexity to O(1). The worst case complexity of insertion and deletion is o(m), where m is number of bins.

\begin{itemize}
  \item Get the median



  \item Insert a value

  When we stream in the input data, we record the first N values. If the stream is smaller than the numberof bins(N), then we can get the exact median. Else, we use insert and delete functions as follows

  \item Delete a value

  Delete a value

\end{itemize}







Final complexity

Maybe graphs

%We have implemented an approximate median algorithm. We divide the incoming data into n bins. Each bin has a frequency
