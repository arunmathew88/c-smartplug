Query 1 requires us to forecast average load of each plug and each house in the system. A day is divided into equally spaced slots of different time slices. The time slices are of length 1 min, 5 min, 15 min, 60 min and 120 min. For example, there will be $(24*60/15) = 96$ slots in a day of the time slice of length 15 min; for the 60 min slice, there will be $(24*60/60) = 24$ slots in a day and so on. The average load forecast is computed over all possible slots of all the time slices.

In order to make a forecast, we use 2 values- current average load and median load for the slot of given time slice. Using these 2 values, we forecast the average load for the next to next slot of the same time slice. We put out a forecast every 30 sec i.e. for each time slice we compute average load whenever we accumulate more data for next 30 seconds. As soon as the time slice is over, after making a forecast, we reinitialize the data corresponding to the time slice.


\subsection{Architecture}
The system consists of a broker process and house processes per house. The broker reads the data file and passes all the events for house id \textit{h} to the corresponding house process as shown in the figure. House process is responsible for the forecast of average load of house and all the plugs in all households in the house.

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[scale=0.8, >=stealth', transform shape, shorten >=1pt, node distance=2cm,auto]
\tikzstyle{every state}=[draw=blue!50, very thick, fill=blue!20]
\node[state] (broker) [text width=1.2cm, align=center] {Broker Process};

\node[state] (h2) [right of=broker,text width=1.2cm, align=center, node distance=4cm] {House 2 Process};
\node[state] (h1) [above of=h2,,text width=1.2cm, align=center] {House 1 Process};
\node[state] (h3) [below of=h2,text width=1.2cm, align=center] {House 3 Process};

\path[->] (broker) edge node[midway, sloped, anchor=south] {h1 events} (h1);
\path[->] (broker) edge node[midway] {h2 events} (h2);
\path[->] (broker) edge node[midway, sloped, anchor=south] {h3 events} (h3);
\end{tikzpicture}
\caption{Query 1 System Architecture}
\end{center}
\end{figure}

In the house process, we keep a 30s accumulator for each plug. Whenever we receive an event for a plug, we increment the accumulator with the load value in the received event. We store a count of values we receive with the timestamp within last 30s in order to calculate average later on. We also keep load value accumulators for different time slices (1m, 5m, 15m, 60m and 120m). 

As soon as we receive an event crossing the 30s time window, we add the value of the accumulator and the count into the time slice accumulators (and similarly the count) and reinitialize the 30s accumulator\footnote{For now, we are ignoring events with work values}. A output forecast is triggered, before setting the 30s accumulator to current load value and count to 1. We predict average load for next to next slot for all the time slices using the average load and the historical median of the corresponding slot for a given time slice. The accumulators for each time slice gets reset to 0 if we get an event crossing the slot boundary. We output forecast as 0 if all the data is missing in a slot for a time slice.

Median Container (MC) used to compute median, provides an interface with inserting a new element and getting the median of all the elements currently in the container. We insert the average load of a plug or house for a given slot of fixed time slice into the container as soon as we compute it. The container returns the exact median of all the average values inserted into it.

\subsection{Median Algorithm (MC)}
For this query, to forecast the load of a plug in a time slice of a specific size, we need the median of the previous average loads for that time slice and for that slice size. For each day and each plug, we have only one value per day of data for that time slice and slice size. So, we store all these values in a container.

In the median container we maintain two heaps. Out of the two, one is a min-heap and the other is a max-heap. Each heap contains about half of the values. Now following three cases can occur:
\begin{itemize}
\item Case 1: The min-heap contains one more element than the max-heap. In this case, the median is the topmost value of min-heap.
\item Case 2: The max-heap contains one more element than the min-heap. In this case, the median is the topmost value of max-heap.
\item Case 3: Both the min-heap and the max-heap contain equal number of elements. In this case, the median is the average of the topmost value of min-heap and the topmost value of max-heap.

\end{itemize}

\subsection{Prediction Model}

\subsection{Experimental Evaluation}
